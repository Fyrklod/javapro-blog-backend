INSERT INTO posts (is_active, moderation_status, moderator_id, user_id, "time", title, text, view_count)
 VALUES (true, 'accepted', 1, 1, '2019-06-01 04:30:24', 'Message', '<div>An enterprise has two separate applications that are communicating via Messaging, using a Message Channel that connects them.</div><div><br></div><div><span style="font-weight: bold;">How can two applications connected by a message channel exchange a piece of information?</span></div><div><br></div><div><img src="\upload\ab\ab\ab\2ea503f9-6676-4cfa-beac-579f7da906fd_MessageSolution.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Package the information into a Message, a data record that the messaging system can transmit through a message channel.</span></div><div><br></div><div>Thus any data that is to be transmitted via a messaging system must be converted into one or more messages that can be sent through messaging channels.</div>', 20)
        ,(true, 'declined', 1, 2, '2020-06-01 02:30:24', 'Human Systems Integration','<div>Human systems integration (HSI) is "the management and technical discipline of planning, enabling, coordinating, and optimizing all human-related considerations during system design, development, test, production, use and disposal of systems, subsystems, equipment and facilities." (SAE 2019).</div><div><br></div><div>Though used by industries around the world, HSI was initiated by the U.S. Department of Defense as part of the "total system approach" to acquisition. The goal of HSI is to "optimize total system performance (hardware, software, and human), operational effectiveness, and suitability, survivability, safety, and affordability." (DoD 2003.)</div><div><br></div><div><br></div><div>HSI activities must be initiated "early in system development (during stakeholder requirements generation) and continuously through the development process to realize the greatest benefit to the final system solution and substantial lifecycle cost savings." (INCOSE 2015).</div><div><br></div><div>HSI generally incorporates the following seven domains as integration considerations (although some organizations may use a slightly different set): manpower, personnel, training, human factors engineering, safety and occupational health, force protection and survivability, and habitability.</div><div><br></div><div><img src="\upload\ab\ef\ef\97a9c901-a036-48dc-8aa4-c7475c842bdb_0870.jpg"></div>', 0)
        ,(true, 'accepted', 1, 1, '2020-06-01 04:30:24', 'Command Message', '<div>An application needs to invoke functionality provided by other applications. It would typically use Remote Procedure Invocation, but would like to take advantage of the benefits of using Messaging.</div><div><br></div><div><span style="font-weight: bold;">How can messaging be used to invoke a procedure in another application?</span></div><div><br></div><div><img src="\upload\ab\cd\ab\7a7034ba-e702-4d75-bd52-883b1df20b87_CommandMessageSolution.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Use a Command Message to reliably invoke a procedure in another application.</span></div><div><br></div><div>There is no specific message type for commands; a Command Message is simply a regular message that happens to contain a command. In JMS, the command message could be any type of message; examples include an ObjectMessage containing a Serializable command object, a TextMessage containing the command in XML form, etc. In .NET, a command message is a Message with a command stored in it. A Simple Object Access Protocol (SOAP) request is a command message.</div>', 5)
        ,(true, 'accepted', 1, 1, '2020-06-01 05:30:24', 'Message Expiration', '<div>My application is using Messaging. If a Message''s data or request is not received by a certain time, it is useless and should be ignored.</div><div><br></div><div><span style="font-weight: bold;">How can a sender indicate when a message should be considered stale and thus shouldn''t be processed?</span></div><div><br></div><div><img src="\upload\ab\ef\ef\1279070b-673a-42d7-8a54-26d99bac74c5_MessageExpirationSolution.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Set the Message Expiration to specify a time limit how long the message is viable.</span></div><div><br></div><div>Once the time for which a message is viable passes, and the message still has not been consumed, then the message will expire. The messaging system''s consumers will ignore an expired message; they treat the message as if it where never sent in the first place. Most messaging system implementations reroute expired messages to the Dead Letter Channel, while others simply discard expired messages; this may be configurable.</div>', 10)
        ,(true, 'accepted', 1, 1, '2020-08-12 23:30:00', 'Splitter', '<div>Many messages passing through an integration solution consist of multiple elements. For example, an order placed by a customer consists of more than just a single line item. As outlined in the description of the Content-Based Router, each line item may need to be handled by a different inventory system. Thus, we need to find an approach to process a complete order, but treat each order item contained in the order individually.</div><div><br></div><div><span style="font-weight: bold;">How can we process a message if it contains multiple elements, each of which may have to be processed in a different way?</span></div><div><br></div><div><img src="\upload\ef\ab\ef\23f2ad91-3de2-4b0f-bec2-1001ed8c537f_Splitter.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Use a Splitter to break out the composite message into a series of individual messages, each containing data related to one item.</span></div><div><br></div><div>use a Splitter that consumes one message containing a list of repeating elements, each of which can be processed individually. The Splitter publishes a one message for each single element (or a subset of elements) from the original message.</div>', 30)
        ,(true, 'accepted', 1, 1, '2020-08-13 12:00:00', 'Message Translator','<div>The previous patterns describe how to construct messages and how to route them to the correct destination. In many cases, enterprise integration solutions route messages between existing applications such as legacy systems, packaged applications, homegrown custom applications, or applications operated by external partners. Each of these applications is usually built around a proprietary data model. Each application may have a slightly different notion of the Customer entity , the attributes that define a Customer and which other entities a Customer is related to. For example, the accounting system may be more interested in the customer''s tax payer ID numbers while the customer-relationship management (CRM) system stores phone numbers and addresses. The application''s underlying data model usually drives the design of the physical database schema, an interface file format or a programming interface (API) -- those entities that an integration solution has to interface with. As a result, the applications expect to receive messages that mimic the application''s internal data format.</div><div><br></div><div>In addition to the proprietary data models and data formats incorporated in the various applications, integration solutions often times interact with standardized data formats that seek to be independent from specific applications. There are a number of consortia and standards bodies that define these protocols, such as RosettaNet, ebXML, OAGIS and many other, industry specific consortia. In many cases, the integration solution needs to be able to communicate with external parties using the ''official'' data formats while the internal systems are based on proprietary formats.</div><div><br></div><div><span style="font-weight: bold;">How can systems using different data formats communicate with each other using messaging?</span></div><div><br></div><div><img src="\upload\ab\cd\cd\0b8a1618-eeb3-4445-9522-5b7fe53b8551_MessageTranslator.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Use a special filter, a Message Translator, between other filters or applications to translate one data format into another.</span></div><div><br></div><div>The Message Translator is the messaging equivalent of the Adapter pattern described in [GoF]. An adapter converts the interface of a component into a another interface so it can be used in a different context.</div>', 50)
        ,(true, 'accepted', 1, 1, '2020-08-13 22:30:00', 'Envelope Wrapper','<div>Most messaging systems divide the message data into a header and a body. The header contains fields that are used by the messaging infrastructure to manage the flow of messages. However, most endpoint systems that participate in the integration solution generally are not aware of these extra data elements. In some cases, systems may even consider these fields as erroneous because they do not match the message format used by the application. On the other hand, the messaging components that route the messages between the applications may require the header fields and would consider a message invalid if it does not contain the proper header fields.</div><div><br></div><div><span style="font-weight: bold;">How can existing systems participate in a messaging exchange that places specific requirements on the message format, such as message header fields or encryption?</span></div><div><br></div><div><img src="\upload\ab\ab\ab\e52faf2d-a2db-4494-b056-f56992102eaf_Wrapper.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Use a Envelope Wrapper to wrap application data inside an envelope that is compliant with the messaging infrastructure. Unwrap the message when it arrives at the destination.</span></div>', 65)
        ,(true, 'accepted', 1, 1, '2020-08-10 10:31:10', 'Point-to-Point Channel', '<div>An application is using Messaging to make remote procedure calls (RPC''s) or transfer documents.</div><div><br></div><div><span style="font-weight: bold;">How can the caller be sure that exactly one receiver will receive the document or perform the call?</span></div><div><br></div><div><img src="\upload\ab\ab\ef\7c6a1119-9fd9-46ae-801b-80ae098bb46c_PointToPointSolution.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Send the message on a Point-to-Point Channel, which ensures that only one receiver will receive a particular message.</span></div><div><br></div><div>A Point-to-Point Channel ensures that only one receiver consumes any given message. If the channel has multiple receivers, only one of them can successfully consume a particular message. If multiple receivers try to consume a single message, the channel ensures that only one of them succeeds, so the receivers do not have to coordinate with each other. The channel can still have multiple receivers to consume multiple messages concurrently, but only a single receiver consumes any one message.</div>', 99)
        ,(true, 'accepted', 1, 1, '2020-08-11 10:00:00', 'Polling Consumer', '<div>An application needs to consume Messages, but it wants to control when it consumes each message.</div><div><br></div><div><span style="font-weight: bold;">How can an application consume a message when the application is ready?</span></div><div><br></div><div><img src="\upload\ef\ef\ab\d4850b2d-7a83-4762-a262-f9e82b8a7332_PollingConsumerSolution.gif"><br></div><div><br></div><div><span style="font-weight: bold;">The application should use a Polling Consumer, one that explicitly makes a call when it wants to receive a message.</span></div><div><br></div><div>This is also known as a synchronous receiver, because the receiver thread blocks until a message is received. We call it a Polling Consumer because the receiver polls for a message, processes it, then polls for another. As a convenience, messaging API''s usually provide a receive method that blocks until a message is delivered, in addition to methods like receiveNoWait() and Receive(0) that return immediately if no message is available. This difference is only apparent when the receiver is polling faster than messages are arriving.</div>', 25)
        ,(true, 'accepted', 1, 2, '2020-08-11 23:00:00', 'Dynamic Router', '<div>You are using a Message Router to route messages between multiple destinations.</div><div><br></div><div><span style="font-weight: bold;">How can you avoid the dependency of the router on all possible destinations while maintaining its efficiency?</span></div><div><br></div><div><img src="\upload\ab\cd\ef\c371cc6f-251b-4665-9b39-cc85065d0e1d_DynamicRouter.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Use a Dynamic Router, a Router that can self-configure based on special configuration messages from participating destinations.</span></div><div><br></div><div>Besides the usual input and output channels the Dynamic Router uses an additional control channel. During system start-up, each potential recipient sends a special message to the Dynamic Router on this control channel, announcing its presence and listing the conditions under which it can handle a message. The Dynamic Router stores the ''preferences'' for each participant in a rule base. When a message arrives, the Dynamic Router evaluates all rules and routes the message to the recipient whose rules are fulfilled. This allows for efficient, predictive routing without the maintenance dependency of the Dynamic Router on each potential recipient.</div>',99)
        ,(true, 'accepted', 1, 2, '2020-08-12 10:00:00', 'Wire Tap','<div>Point-to-Point Channels are often used for Document Messages because they ensure that exactly one consumer will consume each message. However, for testing, monitoring or troubleshooting, it may be useful to be able to inspect all messages that travel across the channel.</div><div><br></div><div><span style="font-weight: bold;">How do you inspect messages that travel on a point-to-point channel?</span></div><div><br></div><div><img src="\upload\ab\ef\cd\9e1f3fdb-3962-40b2-b13e-e0af0ef0231a_WireTap.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Insert a simple Recipient List into the channel that publishes each incoming message to the main channel and a secondary channel.</span></div><div><br></div><div>The Wire Tap is a fixed Recipient List with two output channels. It consumes messages off the input channel and publishes the unmodified message to both output channels. To insert the Wire Tap into a channel, you need to create an additional channel and change the destination receiver to consume of the second channel. Because the analysis logic is located inside a second component, we can insert a generic Wire Tap into any channel without any danger of modifying the primary channel behavior. This improves reuse and reduces the risk of instrumenting an existing solution.</div>', 65)
        ,(true, 'accepted', 1, 2, '2020-08-13 22:00:00', 'Content Enricher','<div>When sending messages from one system to another it is common for the target system to require more information than the source system can provide. For example, incoming Address messages may just contain the ZIP code because the designers felt that storing a redundant state code would be superfluous. Likely, another system is going to want to specify both a state code and a ZIP code field. Yet another system may not actually use state codes, but spell the state name out because it uses free-form addresses in order to support international addresses. Likewise, one system may provide us with a customer ID, but the receiving system actually requires the customer name and address. An order message sent by the order management system may just contain an order number, but we need to find the customer ID associated with that order, so we can pass it to the customer management system. The scenarios are plentiful.</div><div><br></div><div><span style="font-weight: bold;">How do we communicate with another system if the message originator does not have all the required data items available?</span></div><div><br></div><div><img src="\upload\cd\ab\ef\5ad8bb6f-c463-4788-8d75-5a16d5cc4cfc_Enricher.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Use a specialized transformer, a Content Enricher, to access an external data source in order to augment a message with missing information.</span></div><div><br></div><div>The Content Enricher uses information inside the incoming message (e.g. key fields) to retrieve data from an external source. After the Content Enricher retrieves the required data from the resource, it appends the data to the message. The original information from the incoming message may be carried over into the resulting message or may no longer be needed, depending on the specific needs of the receiving application.</div>', 5)
        ,(true, 'new', 1, 2, '2020-12-13 12:51:37', 'Apache Camel','<div><img src="\upload\cd\ab\ab\6b7bc7fb-1ab5-44b3-b4ae-a602b2a7affa_Apache-camel-logo.png"></div><div>Apache Camel is a versatile open-source integration framework based on known Enterprise Integration Patterns.</div><div><br></div><div>Camel empowers you to define routing and mediation rules in a variety of domain-specific languages, including a Java-based Fluent API, Spring or Blueprint XML Configuration files. This means you get smart completion of routing rules in your IDE, whether in a Java or XML editor.</div><div><br></div><div>Apache Camel uses URIs to work directly with any kind of Transport or messaging model such as HTTP, ActiveMQ, JMS, JBI, SCA, MINA or CXF, as well as pluggable Components and Data Format options. Apache Camel is a small library with minimal dependencies for easy embedding in any Java application. Apache Camel lets you work with the same API regardless which kind of Transport is used so learn the API once and you can interact with all the Components provided out-of-box.</div><div><br></div><div>Apache Camel provides support for Bean Binding and seamless integration with popular frameworks such as CDI, Spring and Blueprint. Camel also has extensive support for unit testing your routes.</div><div><br></div><div>The following projects can leverage Apache Camel as a routing and mediation engine:</div><div><ol><li><span style="font-weight: bold;">Apache ServiceMix</span> a popular distributed open source ESB and JBI container</li><li><span style="font-weight: bold;">Apache ActiveMQ</span>a mature, widely used open source message broker</li><li><span style="font-weight: bold;">Apache CXF</span>a smart web services suite (JAX-WS and JAX-RS)</li><li><span style="font-weight: bold;">Apache Karaf</span>a small OSGi based runtime in which applications can be deployed</li><li><span style="font-weight: bold;">Apache MINA</span>a high-performance NIO-driven networking framework</li></ol></div>', 0)
        ,(true, 'new', 1, 2, '2020-12-13 15:42:10', 'Microsoft SSIS (SQL Server Integration Services)','<div>Microsoft SSIS (SQL Server Integration Services) is an enterprise data integration, data transformation and data migration tool built into Microsoft''s SQL Server database. It can be used for a variety of integration-related tasks, such as analyzing and cleansing data and running extract, transform and load, or ETL, processes to update data warehouses.</div><div><img src="\upload\cd\ef\ef\39632e38-a5af-440f-826f-523687941868_96e50dd4416b3a3ec8a769352af21157.png"></div><div><br></div><div>SSIS can extract, transform and consolidate data from multiple relational databases, as well as sources such as XML data files and flat files, then load the processed information into an enterprise data warehouse or other target systems. It includes a set of tools for developing and testing integration programs, called SQL Server Data Tools, plus a server component for deploying and running the programs. In addition, Microsoft''s SQL Server Management Studio software is incorporated into SSIS for managing and monitoring integration routines.</div><div><br></div><div><span style="font-weight: bold;">SSIS history</span></div><div>Microsoft SSIS was introduced with SQL Server 2005 as a replacement for an earlier integration tool called Data Transformation Services (DTS). Before the release of DTS with SQL Server 7.0 in 1998, database administrators either wrote custom data transformation tools or used third-party tools to transfer data.</div><div><br></div><div>Microsoft has added a number of features to SSIS over the years, including graphical tools and wizards, which allow users to build and debug packages; workflow functionality, such as file transfer protocol operations; the ability to execute SQL statements; the ability to email messages; data sources and destinations for ETL; transformations for collecting, cleansing, merging, and copying data; a management service; the ability to administer package execution and storage; and application programming interfaces (APIs) for SSIS object models. Among the most popular features are the data import/export wizard and packaged data source connectors.</div><div><br></div><div><span style="font-weight: bold;">SQL Server 2016 improvements</span></div><div>SQL Server 2016 introduced the SQL Server Integration Services Database Package (SSISDB) Upgrade Wizard. This tool enables IT pros to upgrade the catalog database when it is older than the current version of SQL Server. It can also be used in some disaster recovery situations that require a restoration from backup. The SSISDB Wizard upgrades the catalog database to match whatever version of SQL Server is being used.</div><div><br></div><div>SQL Server 2016 Integration Services enables admins to add an SSIS catalog database to an AlwaysOn Availability Group. It also includes improved package management, where admins can save a container or a control flow task as a reusable template through Integration Services. Also included within SQL Server 2016 was an SSIS Feature Pack for Azure. This allows admins to connect to Azure data sources and to transfer data between the Azure cloud and data sources that are located on premises.</div><div><br></div><div>Microsoft released connectors for SSIS in 2016, including the Connector for SAP Business Warehouse for SQL Server 2016, Connector versions 4.0 for Oracle and Teradata, and the Connector for Analytics Platform System Appliance Update 5.</div><div><br></div><div><span style="font-weight: bold;">SQL Server 2017 improvements</span></div><div>SQL Server 2017 brought new SSIS features, such as Scale Out for SSIS, which makes it easier to run SSIS on multiple machines. Admins can avoid a single point of failure for the entire Scale Out deployment. Also included is an improvement to the failover handling of the executing logs from Scale Out Workers. The execution logs persist to local disk if the Scale Out Worker stops suddenly.</div><div><br></div><div>The SSIS catalog also includes a new global property which specifies the default mode to execute SSIS packages. This applies when IT pros call the stored procedure with the runinscaleout parameter set to null.</div><div><br></div><div><span style="font-weight: bold;">SSIS support</span></div><div>SSIS is version-specific, so users must have the version of SSIS that matches their SQL Server edition. In addition, SSIS isn''t supported in SQL Express or Workgroup editions. Users have to buy the Standard, Business Intelligence or Enterprise editions to get the SSIS designer and runtime components as well as basic data profiling tools and prebuilt transformations. Advanced adapters and advanced transformations are only available in the Enterprise edition.</div>', 0)
        ,(true, 'new', 1, 2, '2020-12-13 18:12:35', 'Messaging','<div>An enterprise has multiple applications that are being built independently, with different languages and platforms. The enterprise needs to share data and processes in a responsive way.</div><div><br></div><div><span style="font-weight: bold;">How can I integrate multiple applications so that they work together and can exchange information?</span></div><div><br></div><div><img src="\upload\ef\ab\ab\c0feb9e7-68d3-411f-b3eb-0a860b35acee_Messaging.gif"><br></div><div><br></div><div><span style="font-weight: bold;">Use Messaging to transfer packets of data frequently, immediately, reliably, and asynchronously, using customizable formats.</span></div><div><br></div><div>Asynchronous messaging is fundamentally a pragmatic reaction to the problems of distributed systems. Sending a message does not require both systems to be up and ready at the same time. Furthermore, thinking about the communication in an asynchronous manner forces developers to recognize that working with a remote application is slower, which encourages design of components with high cohesion (lots of work locally) and low adhesion (selective work remotely).</div>', 0)
        ,(true, 'new', 1, 2, '2020-12-13 21:00:00', 'Microsoft BizTalk Server','<div>Microsoft BizTalk Server (or simply "BizTalk") is an Inter-Organizational Middleware System (IOMS) that enables companies to automate business processes, through the use of adapters which are tailored to communicate with different software systems used in an enterprise. Created by Microsoft, it provides enterprise application integration, business process automation, business-to-business communication, message broker and business activity monitoring.</div><div><img src="\upload\ab\ab\cd\3df541b1-9542-4873-96bd-872590b1ebde_biztalk-Edit.jpg"><br></div><div>BizTalk Server was previously positioned as both an application server and an application integration server. Microsoft changed this strategy when they released the AppFabric server which became their official application server. Research firm Gartner consider Microsoft''s offering one of their ''Leaders'' for Application Integration Suites. The latest release of Biztalk (Biztalk Server 2020) was released on 15th of January 2020.</div><div><br></div><div>In a common scenario, BizTalk enables companies to integrate and manage automated business processes by exchanging business documents such as purchase orders and invoices between disparate applications, within or across organizational boundaries.</div><div><br></div><div>Development for BizTalk Server is done through Microsoft Visual Studio. A developer can create transformation maps transforming one message type to another. For example, an XML file can be transformed to SAP IDocs. Messages inside BizTalk are implemented through the XML documents and defined with the XML schemas in XSD standard. Maps are implemented with the XSLT standard. Orchestrations are implemented with the WS-BPEL compatible process language xLANG. Schemas, maps, pipelines and orchestrations are created visually using graphical tools within Microsoft Visual Studio. The additional functionality can be delivered by .NET assemblies that can be called from existing modules-including, for instance, orchestrations, maps, pipelines, business rules.</div>', 0)
;